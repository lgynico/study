# 算法与数据结构

## 基础
### 时间复杂度
|大O|备注|常见操作|
|-|-|-|
|O(1)|常数时间，与数据规模无关|位运算，赋值，比较，交换|
|O(logN)|||
|O(N)|||
|O(NlogN)|||
|O(N^2^)|||
|O(N^3^)|||
|O(2^N^)|||
|O(3^N^)|||
|O(k^N^)|||

### 额外空间复杂度
|大O|备注|常见操作|
|-|-|-|
|O(1)|未使用额外空间|使用有限变量，集合原地操作|
|O(N)|与数据规模同等的空间|使用集合保存中间结果|

## 数据结构


## 算法
### 排序算法
#### 选择排序
每次选择一个最小的值交换到前面
|时间|空间|
|-|-|
|O(N^2^)|O(1)|
```go
// 伪代码
fn selectionSort(arr) {
    for i in 0 to length(arr)-1 {
        let minIndex = i
        for j in 1 to length(arr) {
            if arr[minIndex] < arr[j] {
                minIndex = j
            }
        }
        swap(arr, i, minIndex)
    }
}
```

#### 冒泡排序
每次比较并交换两个值，把最大值排到最后面
|时间|空间|
|-|-|
|O(N^2^)|O(1)|
```go
fn bubbleSort(arr) {
    for i in length(arr) to 1 {
        for j in 0 to i {
            if arr[j] > arr[j+1] {
                swap(arr, j, j+1)
            }
        }
    }
}
```

#### 插入排序
每次拿到当前的值往前比较并交换，直到遇到不小于的数
|时间|空间|
|-|-|
|O(N^2^) [特殊情况下O(1)]|O(1)|
```go
fn insertionSort(arr) {
    for i in 1 to length(arr)-1 {
        for j in i to 0 {
            if arr[j] >= arr[j-1] {
                continue
            }
            swap(arr, j, j-1)
        }
    }
}
```

### 搜索算法
#### 二分查找
在一个有序数组中，每次从中间开始对半比较
|时间|空间|
|-|-|
|O(logN)|O(1)|
```go
fn binarySearch(arr, target) int {
    let min = 0
    let max = length(arr)
    while (min < max) {
        let middle = (min + max) / 2
        if (arr[middle] > target) {
            max = middle
        } else if (arr[middle] < target) {
            min = middle
        } else {
            return middle
        }
    }

    return arr[min] == target ? min : -1
}
```