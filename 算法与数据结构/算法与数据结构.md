# 算法与数据结构

## 基础
### 算法的复杂度
#### 时间复杂度
|大O|备注|常见操作|
|-|-|-|
|O(1)|常数时间，与数据规模无关|位运算，赋值，比较，交换|
|O(logN)|||
|O(N)|||
|O(NlogN)|||
|O(N^2^)|||
|O(N^3^)|||
|O(2^N^)|||
|O(3^N^)|||
|O(k^N^)|||

#### 额外空间复杂度
|大O|备注|常见操作|
|-|-|-|
|O(1)|未使用额外空间|使用有限变量，集合原地操作|
|O(N)|与数据规模同等的空间|使用集合保存中间结果|

### 算法的解题方法
#### 递归
##### Master 公式
直接算出递归的时间复杂度
> T(N) = a * T(N/b) + O(N^d^) // a, b, d 均为常数

当 log~b~a < d : O(N^d^)
当 log~b~a > d : O(N^log~b~a)
当 log~b~a == d : O(N^d^ * logN)

#### 暴力破解
#### 动态规划

## 数据结构
### 数组
### 链表
#### 单链表
链表节点有一个指向下一个节点的指针
为了保证操作简单会进行封装
```go
struct Node {
    T data;
    Node *next;
}

struct List {
    Node *head;
    Node *tail;
    int size;
}
```
##### 插入
链表为空时，直接赋值为头尾节点
链表不为空时，连接到尾节点的下一个节点并把尾指针指向当前节点
```go
function Insert(list, element) {
    var node = new node with element

    if list is empty {
        assign: node → list.head
        assign: node → list.tail
    } else {
        assign: node → list.tail.next
        assign: node → list.tail
    }

    increment list.size
}
```
##### 删除
从头节点开始依次对比，让前节点的下个指针指向下一个节点
注意：删除节点可能会删除头尾节点，需要对头尾指针特殊处理
```go
function Remove(list, element) {
    var dummy = new node with next pointer to list.head
    var prev = dummy
    var curr = list.head

    loop with curr is not null {
        if curr.data is equals to  element {
            assign: curr.next → prev.next
            decrement list.size
            if curr is list.tail { // remove may change tail
                assign: prev → list.tail
            }
        }

        assign: curr → prev
        assign: curr.next → curr
    }

    assign: dummy.next → list.head // remove may change head
}
```
##### 查询
```go
function Get(list, index) {
    if index >= list.size {
        return null
    }

    var node = list.head
    for i increment from 1 to index {
        assign: node.next → node
    }

    return node
}
```
##### 反转
使用三个指定，分别为当前节点，前一个节点和下一个节点
让当前节点的 next 指针指向前一个节点
最后交换头尾指针
```go
function Reverse(list) {
    if list.size <= 1 {
        return
    }

    var prev = null
    var curr = list.head

    loop while curr is not null {
        var next = curr.next
        assign: prev → curr.next
        assign: curr → prev
        assign: next → curr
    }

    swap list.head and list.tail
}
```

#### 双链表
链表节点有一个指向下一个节点的指针和一个指向前一个节点的指针
```go
struct Node {
    T data;
    Node* prev;
    Node* next;
}

struct DoubleList {
    Node *head;
    Node *tail;
    int size;
}
```
##### 插入
链表为空时，直接赋值为头尾节点
链表不为空时，连接到尾节点的下一个节点，当前节点的 prev 指向尾节点
尾指针指向当前节点
```go
function Insert(list, element) {
    var node = new node with element

    if list is empty {
        assign: node → list.head
        assign: node → list.tail
    } else {
        assign: node → list.tail.next
        assign: list.tail → node.prev
        assign: node → list.tail
    }

    increment list.size
}
```
##### 删除
把前一个节点的 next 指向当前节点的下一个节点
把下一个节点的 prev 指向当前节点的上一个节点
使用虚拟节点作为头节点可以杜绝删除 head 节点的情况
需要处理删除了 tail 节点的情况
```go
function Remove(list, element) {
    if list is empty {
        return
    }

    var dummy = new node with pointer each other to list.head
    var curr = list.head

    loop while curr is not null {
        if curr.data equals to element {
            assign: curr.next → curr.prev.next
            if curr.next is not null {
                assign: curr.prev → curr.next.prev
            }

            if curr equals to list.tail {
                assign: curr.prev → list.tail
            }

            assign: null → curr.prev
            decrement list.size
        }

        assign: curr.next → curr
    }

    assign: dummy.next → list.head
    if list.head.prev is not null {
        assign: none → list.head.prev
    }
    if list.tail equals to dummy {
        assign: none → list.tail
    }
}
```
##### 查询
与单链表一样
```go
function Get(list, index) {
    if index >= list.size {
        return null
    }

    var node = list.head
    for i increment from 1 to index {
        assign: node.next → node
    }

    return node
}
```
##### 反转
只需要对调当前节点的 prev 和 next
最后交换 head 和 tail
```go
function Reverse(list) {
    if list.size <= 1 {
        return
    }

    var prev = null
    var curr = list.head
    loop while curr is not null {
        var next = curr.next
        assign: prev → curr.next
        assign: next → curr.prev
        assign: curr → prev
        assign: next → curr
    }

    swap list.head and list.tail
}
```

### 队列
先进先出的逻辑结构
#### 单向队列
##### 使用数组实现
##### 使用链表实现
##### 使用栈实现
#### 双端队列
##### 使用数组实现
##### 使用链表实现
##### 使用栈实现

### 栈
后进先出的逻辑结构
##### 使用数组实现
##### 使用链表实现
##### 使用队列实现
##### O(1) 最小栈

### 哈希表

### 树
### 图

## 算法
### 位运算
#### 异或运算 xor
相同为0，不同为1（相当于无进位相加）
```go
1 ^ 0 = 1
1 ^ 1 = 0
N ^ 0 = N
N ^ M = 0
```

##### 交换两个变量
```go
func swap(arr, i, j) {
    if (i == j) return;
    arr[i] = arr[i] ^ arr[j];
    arr[j] = arr[i] ^ arr[j];
    arr[i] = arr[i] ^ arr[j];
}
```

##### 找出二进制整数最右的1
```go
a = a & ((~a)+1);
a = a & (-a);
```

##### 找出数组中出现了奇数次的数
数组的异或结果
```go
func findOddTimesInArray(arr) int {
    let xor = 0;
    for each num in arr {
        xor = xor ^ num;
    }
    return xor;
}
```

##### 找出数组中出现了奇数次的两个数
数组的异或结果为两数的异或，找出结果中任意一个1位，把数组分成两组，求这两组的异或结果
```go
func findOddTimesInArray(arr) (int, int) {
    let xor = xor each num in arr;
    let rightOne = xor ^ (-xor);
    let xorx = 0;
    for each num in arr {
        if (arr & rightOne) == rightOne {
            xorx = xorx ^ arr; // a or b
        }
    }

    return xorx, xor ^ xorx;
}
```

##### 找出数组中出现了 K 次的数
一个数出现了 K 次，其它都出现了 M 次，并且 `M > 1, K < M`
准备一个数组，记录所有数的二进制位为 1 的数量，找出不为 M 的整数倍的所有位
```go
func findKTimes(arr, k, m) int {
    let bits[32];
    for each num in arr {
        for i in 0 to 31 {
            if num bit in i is 1 {
                bits[i]++;
            }
        }
    }

    let ans = 0;
    for i in 0 to 31 {
        if bits[i] % m != 0 {
            ans |= 1 << i;
        }
    }

    return ans;
}
```

##### 找出数组中出现了 K 次的数，也可能不存在 K 次的数
// TODO

### 排序算法
#### 选择排序
每次选择一个最小的值交换到前面
|时间|空间|
|-|-|
|O(N^2^)|O(1)|
```go
// 伪代码
fn selectionSort(arr) {
    for i in 0 to length(arr)-1 {
        let minIndex = i
        for j in 1 to length(arr) {
            if arr[minIndex] < arr[j] {
                minIndex = j
            }
        }
        swap(arr, i, minIndex)
    }
}
```

#### 冒泡排序
每次比较并交换两个值，把最大值排到最后面
|时间|空间|
|-|-|
|O(N^2^)|O(1)|
```go
fn bubbleSort(arr) {
    for i in length(arr) to 1 {
        for j in 0 to i {
            if arr[j] > arr[j+1] {
                swap(arr, j, j+1)
            }
        }
    }
}
```

#### 插入排序
每次拿到当前的值往前比较并交换，直到遇到不小于的数
|时间|空间|
|-|-|
|O(N^2^) [特殊情况下O(1)]|O(1)|
```go
fn insertionSort(arr) {
    for i in 1 to length(arr)-1 {
        for j in i to 0 {
            if arr[j] >= arr[j-1] {
                continue
            }
            swap(arr, j, j-1)
        }
    }
}
```

#### 归并排序

##### 递归版本

##### 迭代版本



### 搜索算法
#### 二分查找
在一个有序数组中，每次从中间开始对半比较
|时间|空间|
|-|-|
|O(logN)|O(1)|
```go
fn binarySearch(arr, target) int {
    let min = 0
    let max = length(arr)
    while (min < max) {
        let middle = (min + max) / 2
        if (arr[middle] > target) {
            max = middle
        } else if (arr[middle] < target) {
            min = middle
        } else {
            return middle
        }
    }

    return arr[min] == target ? min : -1
}
```

### 路径搜索算法
#### 深度搜索
#### 广度搜索
#### Dijkstra 算法
#### A*
从起点开始，每次找到一个代价最小的节点，直到找到终点。
代价计算公式：`F = G + H`
|符号|作用|备注|
|-|-|-|
|`F`|总代价||
|`G`|起点到当前节点的代价||
|`H`|当前节点到终点的代价|由启发式函数计算|

启发式函数
|名称|作用|备注|
|-|-|-|
|欧几里德距离|点到点的直线距离|存在浮点数和开方操作性能低|
|曼哈顿距离|点到点的水平距离加直线距离||
|对角线加直线距离|适用于可以对角线移动的情况|直接假设对角线的距离为N|

伪代码
```go
func Astar(map, src, dst) path {
    let queue = PriorityQueue{}
    let parent = map<point, point>
    let fcost = map<point, int>
    let gcost = map<point, int>
    let visited = set<point>
    let found = false

    queue.enqueue(src)

    while (queue is not empty) {
        let currentPoint = queue.deque()
        foreach point in neighbors(currentPoint) {
            if point is wall or point in visited {
                continue
            }
            parent[point] = currentPoint
            if point == dst {
                found = true
                break
            }
            gcost[point] = gcost[parent(point)] + 1
            fcost[point] = gcost[point] + heuristic(point, dst)
        }
    }

    if not found {
        return nil
    }

    let path = []
    for point in dst to src {
        path.append(point)
    }
    return path
}
```



## 例题
### 归并排序
#### 小和问题：累加数组 i 位置左边的较小数，并算出所有累加数的和

#### 求逆序对：计算数组 i,j (i < j) 为逆序的全部数量

#### 求2倍小数：计算数组 i 位置右边比一半小的数，累加所有数量